<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo博客工具使用精粹]]></title>
    <url>%2FTools%2Fhexo-using-essences%2F</url>
    <content type="text"><![CDATA[主题管理大多数时候我们需要使用到第三方主题来进行我们博客站点的美化，一般来说都是通过git clone的方式拷贝到本地的themes目录里。但是这种clone到本地的第三方仓库是无法在git push时发布到远程仓库的，一旦你在另一台机器上新clone了一份自己仓库，你会发现themes下所有的内容都丢失了，又要重新clone一份，如果你还对第三方主题配置进行过很多修改，重新拷贝一份的话就意味着得重新再做一次修改，这会带来极大的不便。所以，我们需要找到一种方式来解决这些问题。幸好，git提供了一种subtree（1.5.2版本之前有submodule）的机制，我们可以利用fork+subtree的机制来进行第三方库的管理。 删除themes目录下的next文件夹，并将修改push到远程。 进入next主题的github首页，fork之。 fork完成后，绑定next项目为子项目： 12git remote add -f next git@github.com:HalZhan/hexo-theme-next.gitgit subtree add --prefix=themes/next next master --squash 更新子项目： 12git fetch next mastergit subtree pull --prefix=themes/next next master --squash 从子目录push修改到远程仓库： 1git subtree push --prefix=themes/next next master 提交并发布本地修改到远程仓库： 123git add .git commit -m "next theme"git push 现在再去远程仓库看themes/next目录下就有内容了，而且同子项目的远程仓库保持同步，在主项目的子项目文件目录里所做的修改也可以push到子项目的远程。这样就不必担心主题配置丢失了。 推荐列表hexo 官方有一份 wiki 记录了目前比较流行的主题。可以点击此处查看。 搜索本地开启本地搜索的话需要安装依赖：1npm install hexo-generator-search --save 如果你使用的是next主题，可能需要安装其自身需要的依赖：1npm install hexo-generator-searchdb --save 这两个只要选择安装一个即可。 接下来前往项目根目录下的_config.yml修改或添加如下字段：（注意空格）123456# Searchingsearch: path: search.xml field: post format: html # next主题识别 limit: 10000 # next主题识别 然后前往next主题文件夹里的_config.yml中将本地搜索功能启动：12local_search: enable: true 重新生成站点文件后进行本地伺服浏览：123hexo cleanhexo ghexo server -d 不过笔者在使用本地搜索时很大几率碰到搜索弹层无法展现的问题，查看了下返回的search.xml的内容，发现如下内容：1error on line 6 at column 35: Input is not proper UTF-8, indicate encoding ! Bytes: 0x08 0xE5 0xAF 0xB9 很显然，我们的内容中存在非utf-8字符，使用你的编辑器可以查看下控制字符。应该会发现存在 BS 这样的控制字符。一一删除掉（或统一替换为&quot;&quot;），重新生成，应该就会没问题了。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Tools</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无损音乐压缩格式ape与flac]]></title>
    <url>%2FTechnology%2Fape-and-flac%2F</url>
    <content type="text"><![CDATA[无损压缩是在保证不损失源文件所有码率的前提下，将音频文件压缩的更小，也就是说这两种音频格式都能保证源文件码率的无损。但两种压缩格式毕竟为两种压缩算法，下面列举一下两种压缩格式的异同点： 相同点：一、压缩比决定无损压缩文件所占存储空间 FLAC与AEP的压缩比基本相同，FLAC的压缩比为58.70%，而APE的压缩比则要更高一些，为55.50%，都能压缩到接近源文件一半大小。 二、编码速度考验用户的耐心，速度快者优 非常值得赞扬的是，FLAC与APE的编码速度都相差无几，这是因为两者的压缩技术是开源的，开发者可以借鉴两者在编码上的不同优势进行开发，不过目前编码速度最快的是WavPack和Shorten两种无损压缩格式，但这两种格式的非开源性限制了其普及。 三、平台的支持决定普及度 音频压缩不但需要硬件的支持，也需要的软件的支持，因此能够被更广泛的平台支持，也就意味着被更多用户使用。FLAC与APE在这方面做的都非常出色，能够兼容所有系统平台，现在无论您是Windows用户还是众多版本的Linux用户，哪怕您是Mac OS的忠实FANS，都无需担心无法使用FLAC或APE。 四、两者的开源特性，完全免费的技术 两者的开源特性，意味着任何组织或个人都可以免费使用这两种压缩技术，任何组织或个人都可以修改和发布基于这两种技术的新产品，这给众多MP3厂商降低成本提供了有力保障，且消费者也能够以相对低廉的价格购买到只有世界级MP3（例如：iPod支持ALAC）才支持的无损压缩音频、CD级的音质表现！ 不同点：一、自我纠错能力，谁更人性化 很多消费者都经历过MP3的爆音问题，然后归咎于MP3质量有问题，其实，很大一部分爆音是因为音频压缩过程中，编码的微小损坏，造成在解码时，处理出来的数据与音频不一致，导致爆音现象。无损格式压缩的不好也会导致编码损坏，而在处理这种问题时，FLAC的会以静音方式代替有损部分，而APE的处理则与常见的有损压缩格式处理的方式相同，以爆音方式代替有损部分。这一点FLAC设计的更人性化！ 二、优化的编码结构，决定了解码的速度 由于编码方式的不同，将影响两种无损压缩格式的解码速度，通常FLAC的解码速度比APE快30%，这是因为，FLAC只需执行整数运算，而无需执行占用系统更高频率和更大数据处理量的浮点运算。基于这一点，一般硬件均可完美实现实时解码。 三、方便的资源获取，意味着能够得到更广泛的应用与支持 无论FLAC还是APE，在资源获取上，两者都能通过网络搜索轻松获得！ 通过以上的对比，相信很多用户对FLAC和APE的认识更加深了一些，单从技术角度讲，FLAC要明显比APE优秀，原因在于，FLAC是第一个开源的且被世界公认的无损压缩格式，有来自世界各地的顶尖级开发高手对FLAC进行免费的开发与技术完善，同时，FLAC有广泛的硬件平台的支持，几乎所有采用便携式设计的高端解码芯片都能够支持FLAC格式的音乐，FLAC第三个优势在于：优秀的编码使得硬件在解码时只需采用简单的整数运算即可，这将大大降低所占用的硬件资源！不过两种公开的技术具有极强的互补性，任何一方都不可能全面超越另一方！ ape，flac哪个好？ 要回答这个问题之前，咋们先来说说ape和flac是怎么来的。（你别跟我说你的ape和flac是用MP3转换过来的）要得到无损音乐，首先是把CD抓轨到电脑里，变成WAV。那么有人会问，抓轨变成WAV，相比原来的CD，音质会不会有损失呢？答案是：很有可能有损失，但是也可以做到完全没有任何损失。 说到底，CD就是一张记录一堆010101的塑料片，只要你能把010101都读对了，那你得到的WAV就和原来的CD音质一模一样。可惜的是，一般情况下，都会由于各种各样的原因，导致不能完全读对。（比如光驱的质量，CD碟片用久了读错几率变高等等）为了增加你读到的010101完全正确的几率，需要使用EAC等专业抓轨软件来抓轨，而不是用foobar直接转换甚至是用WMP之类的。（虽然用EAC也不能保证绝对正确，但是完全正确的几率已经非常高了）。 好了，假设你现在得到了一个完全没有读错的WAV。然后你通过格式的转换，就可以得到ape和flac。WAV是1411KBPS，而ape一般只有几百KBPS，有的人以为，文件小了这么多，里面肯定是损失了些什么了吧。好了，现在大家一起来看看，转换格式的时候到底发生了什么？为什么好好的一个WAV文件，转换成ape和flac会小了这么多？具体的情况相当的复杂，咋们用一个简单的例子来说明一下。格式转换实际上是编码的转换。 编码是什么？你可以理解成记录信息的方式。假设一个柜子，里面有5*5这么多个抽屉，里面放了A和B两样东西。12345A B A B AB A B A BA B A B AB A B A BA B A B A WAV就相当于是以这种列表的方式来记录A和B的排列。 而ape和flac呢，是怎么记录这个排列的？让我们来看看。设两个量N和M，以N来代表行数，以M来代表列数。N可以取1~5，M也可以取1~5。在这个范围内，当N+M为偶数的时候，抽屉里的是A，当N+M为奇数的时候，抽屉里是B。 记录的信息就变成了： N=1~5，M=1~5 当（N+M）/2取余数等于0时，抽屉（N，M）里的东西是A，不等于0时，抽屉（N，M）里的东西是B。 看起来好像是后面的方法更复杂嘛，那是因为抽屉只有5*5这么少。当抽屉变成500*500呢，500W*500W呢？用前面的方法记录是不是需要非常大的空间？ape和flac记录的方法是不是简单了很多呢？（记录的文件当然就变小了）但是大家来看看，它们记录的东西有没有变？有没有损失？答案是：没有的。当然，音频信息的记录比这个复杂多了，所以压缩比率只能做到一半左右，还是无数人想破脑袋才想出来的。 好了，现在大家知道了，ape和flac是两种比WAV更先进的音频记录方式，那到底哪一个好点？ape和flac的区别就是算法（用数学方法优化记录方式）不同，其实是差不多的两样东西。现在大家知道了，同一个WAV文件转换成ape和flac，里面都并没有损失掉什么，但是呢，flac有一个特点：消除爆音。或者说可以这样说：flac会用静音代替由于某些特定原因造成的爆音。（所以flac还是会有爆音的）还有个区别：ape压缩率比flac高一点，所以ape文件体积较小，但是对随身听来说，由于ape算法比flac复杂，所以要更加耗电。 总结：1、很多人误以为无损的音质比不上CD，实际上，最烂的硬盘里面装的无损，也比天价转盘读原版CD要好。原因无它，转盘即使再好，也有读错的时候，但是硬盘是不可能读错的。关键是你要弄到一个完全没有抓轨出错的无损。 2、ape和WAV之间的相互转换并不会有任何的损失，同一个WAV转换出来的ape，可能存在不同的比特率，但是各个不同比特率的ape音质是一样的。Flac也是一样，别以为L10的flac声音会比L0的flac声音好，L10的flac只是体积更小，更耗电而已。 补充： 硬盘绝对不出错，就因为它有CRC校验，出错了就是硬盘坏了，而且会有相应的报错或很容易校验出来。一个没坏的硬盘，不管硬盘底层的结构是否有读错或屏蔽错误，最后返回到软件层的数据，必然是一字节也不差的，绝对不存在错了还无法发现的情况，否则你的系统早就崩溃了。而CD跟硬盘不一样，它没有校验，读对读错谁也不知道，所以才不可靠，这一点跟硬盘是有本质的不同的。 再谈APE和FLAC，这两种格式是由WAV压缩而产生，FLAC在运算上某些方面优于APE，这也是为什么国外喜欢选用这种格式，但总体上FLAC和APE没区别，在WAV格式压缩成APE和FLAC过程中会影响到音质这点不可否认，最简单和直观的就是频谱被破坏了，21KHz以上被认为人耳听不到的声音完全删除，从而在中档音响上音质听起来显得干涩偏硬，声场明显收缩，但在普通电脑设备和普通耳机上很难分辨出来，这主要是受设备影响，但事实的存在不能以低端的普通电脑设备做为判定的标准的器械而加于否认。 再一点，某些人不熟悉音频流在转换、压缩时的损耗，而是简单的认为把APE或FLAC还原成WAV在文件上没损耗，理论依据是RAR压缩原理，把APE或FLAC转换成WAV再把文件改成TXT后，再一个字节一个字节的去对照，然后如哥伦布发现新大陆一般宣布还原后的文件大小一模一样，我真的很佩服这些人的“求知”精神，接着再浪费一大把时间，在普通的电脑设备上听后得出的结论是“都一样”。不知道这些人是否认真查考过频谱的损耗？是否掩耳盗铃的认为21KHz以上的声音听不到就可以不需要？是否将来你在攒到自己的中档音响设备后，在如此这般的转换后自己听出问题后，你是否会为今日的错误结论而脸红？也许你还会坚持你的论点说为什么APE或FLAC还原成WAV后和原来未经过压缩的WAV文件一样？这要归功于CRC码的校验，在软件无法修复你的文件时，它就利用大量的静音来填充，彻底的山寨一把来完成你交给的不得不完成的任务，因为你家的电脑完全接受你的指挥。写到这里我真要吐血，我得诅咒那MZY7213以后买方便面时袋里没面块。 频谱的损坏在没有专用软件编辑下无法修复，而这软件具有专利权而无法成为免费的软件。频谱是记载声波文件的一种十六进制运算法的直观图谱，频谱的缺失已经彻底肯定了音频的耗损，所以盲目认为没有损耗的观念是错误的。 再接着继续讨论压缩问题，曾有人问过，WAV经过压缩后再解压是否有耗损，我个人感觉有点吹毛求疵了。WAV的精度已经限定在16Bit/44.1KHz，4位立体声的参数上，不管你家的CD是18 Bit、20 Bit、24 Bit或是SACD、XRCD，K2、HD，音频采样也不管你是44.1KHz直到192KHz，从双声道到多声道，通通纳入到16Bit/44.1KHz，4位立体声成为普通CD格式，那你还在追求什么好音质？在此时所有的18 Bit、20 Bit、24 Bit或是SACD、XRCD，K2、HD，或是音频采样44.1KHz直到192KHz全部瞬间成为标题党而不存在于WAV文件里，要想达到封面上的音质要求？那你掏银子买碟整设备去。 WAV是PCM运算法，RAR压缩软件开发是用于文档资料的加密管理，是两种完全不一样的运算方式，很不幸它们都能植入到WINDOS系统上，（我个人感觉是很万幸）所以才会给那么多人产生那么多不必要的问题。我想简单的问个问题，在压缩574M的WAV经过RAR压缩后成为356M体积明显缩小，损失了？APE，FLAC文件的压缩你发现了什么？压缩后的包要嘛等于或略小于原文件的体积大小，要嘛大于原文件的体积。那么多出来的是增强了？还是损失了？其实多出来的是压缩文件的导引头。上面提到WAV是运用“0”和“1”码来控制转换，那么已经是数码化了，只要你不利用专项工具破坏它的音频码，RAR压缩对其不产生破坏性。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的prototype和__proto__]]></title>
    <url>%2FFrontend%2FJavascript%2Fprototype-and-proto-in-js%2F</url>
    <content type="text"><![CDATA[一、prototype和proto的概念prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。 __proto__是一个对象拥有的内置属性（请注意：prototype是函数的内置属性，__proto__是对象的内置属性），是JS内部使用寻找原型链的属性。 用chrome和FF都可以访问到对象的__proto__属性，IE不可以。 二、new的过程12var Person = function()&#123;&#125;;var p = new Person(); new的过程拆分成以下三步： (1) var p={}; 也就是说，初始化一个对象p (2) p.__proto__ = Person.prototype; (3) Person.call(p); 也就是说构造p，也可以称之为初始化p 关键在于第二步，我们来证明一下： 123var Person = function()&#123;&#125;;var p = new Person();alert(p.__proto__ === Person.prototype); 这段代码会返回true。说明我们步骤2是正确的。 三、示例1234567var Person = function()&#123;&#125;;Person.prototype.sayName = function() &#123; alert(&quot;My Name is Hal&quot;);&#125;;Person.prototype.age = 24;var p = new Person();p.sayName(); p是一个引用指向Person的对象。我们在Person的原型上定义了一个sayName方法和age属性，当我们执行p.age时，会先在this的内部查找（也就是构造函数内部），如果没有找到然后再沿着原型链向上追溯。 这里的向上追溯是怎么向上的呢？这里就要使用__proto__属性来链接到原型（也就是Person.prototype）进行查找。最终在原型上找到了age属性。]]></content>
      <categories>
        <category>Frontend</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Frontend</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js简述]]></title>
    <url>%2FBackend%2FNode-js%2Fnode-intro%2F</url>
    <content type="text"><![CDATA[什么是NodeJS Node.js采用模块化结构，按照CommonJS规范定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。 JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。 每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了fs、http等内置对象。 Node.js 被设计用来开发大规模高并发的网络应用，这种网络应用的瓶颈之一是在 I/O 的处理效率上。由于硬件及网络的限制，I/O 的速度往往是固定的，如何在此前提下尽可能处理更多的客户请求，提高 CPU 使用效率，便成了开发人员面临的最大问题。得益于基于事件驱动的编程模型，Node.js 使用单一的 Event loop 线程处理客户请求，将 I/O 操作分派至各异步处理模块（这里一般人不理解，node.js包含很多模块，这些模块可以使用js直接调用系统的api），既解决了单线程模式下 I/O 阻塞的问题，又避免了多线程模式下资源分配及抢占的问题。 事件模型单线程模式 客户端发起一个 I/O 请求(数据库查询)，然后等待服务器端返回 I/O 结果，结果返回后再对其进行操作，但这种请求常常需要很长时间（对于服务器的 CPU 处理能力来说）。这一过程中，服务器无法接受新的请求，即阻塞式 I/O。这种处理方式虽然简单，却不实用，尤其是面对大量请求的时候，简直就不可用。这种情景类似在火车站售票窗口排队买票，如果您在春节期间去北京火车站排队买过票，绝不会认为这是一种好的处理方式。庆幸的是，现在很少有服务器采取这种处理方式。 多线程模式 该方式下，服务器为每个请求分配一个线程，所有任务均在自己的线程内执行，就像火车站多开了几个卖票窗口，处理效率高了许多。但就如读者看到的那样，在春节期间各个售票窗口前还是人满为患，为什么火车站不再多开一些售票窗口呢？当然是因为成本。线程也一样，服务器每创建一个线程，每个线程大概会占用 2M 的系统内存，而且线程之间的切换也会降低服务器的处理效率，基于成本的考虑，这种处理方式也有一定的局限性。然而，这却不是最主要的，主要的是开发多线程程序非常困难，容易出错。程序员需考虑死锁，数据不一致等问题，多线程的程序极难调试和测试。基本上在程序运行出错的时候，程序员才知道自己的程序有错误。而这种错误的代价往往又是巨大的，那些访问量巨大的电子商务网站时常会曝出价格错误等导致公司损失的新闻。 事件驱动 客户发起 I/O 请求的同时传入一个函数，该函数会在 I/O 结果返回后被自动调用，而且该请求不会阻塞后续操作。就像电话订票，设想你一大早来到办公室，给火车站打个电话，将自己的票务信息，地址告诉对方，然后放下电话，泡杯茶，浏览一下网页，回复一下今天的电子邮件，你完全不用管火车票的事了，如果订到票，火车站会派快递公司按你电话中提到的联系方式送票给你。无疑，这是一种极其理想的处理方式。所有请求以及同时传入的回调函数均发送至同一线程，该线程通常叫做 Event loop 线程，该线程负责在 I/O 执行完毕后，将结果返回给回调函数。这里要注意的是 I/O 操作本身并不在该线程内执行，所以不会阻塞后续请求。比如：请求a要访问数据库，请求b要访问文件系统，假设Event loop先接受到a请求，这时Event loop会把a的回调方法交给处理访问数据库的异步处理模块。然后Event loop就可以去接受请求b,并把b的回调方法交给处理文件系统的一部处理模块。然后Event loop继续等待请求。当访问数据的异步处理模块处理完成后，会主动调用a的回调方法。在a的回调方法中，就会给客户a发送查询到的数据（当然这里需要短暂的使用Event loop来操作）。 为什么选用 JavaScript 事实上，在实现 Node.js 之初，作者Ryan Dahl并没有选择 JavaScript，他尝试过 C、Lua，皆因其欠缺一些高级语言的特性，如闭包、函数式编程，致使程序复杂，难以维护。而 JavaScript 则是支持函数式编程范型的语言，很好地契合了 Node.js 基于事件驱动的编程模型。加之 Google 提供的 V8 引擎，使 JavaScript 语言的执行速度大大提高。最终呈现在我们面前的就成了 Node.js，而不是 Node.c，Node.lua 或其他语言的实现。Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。Javascript在动态语言中性能较好，有开发人员对Javacript、Python、Ruby等动态语言做了性能分析，发现Javascript的性能要好于其他语言，再加上V8引擎也是同类的佼佼者，所以Node.js的性能也受益其中。 Node.js采用C++语言编写而成，是一个Javascript的运行环境。为什么采用C++语言呢？据Node.js创始人Ryan Dahl回忆，他最初希望采用Ruby来写Node.js，但是后来发现Ruby虚拟机的性能不能满足他的要求，后来他尝试采用V8引擎，所以选择了C++语言。 Node.js采用了Google Chrome浏览器的V8引擎，性能很好，同时还提供了很多系统级的API，如文件操作、网络编程等。 Node.js是一个后端的Javascript运行环境（支持的系统包括Linux、Windows），这意味着你可以编写系统级或者服务器端的Javascript代码，交给Node.js来解释执行。 多核处理器情况下 NodeJS中的JavaScript确实是在单线程上执行，但是作为宿主的NodeJS，它本身并非是单线程的，NodeJS在I/O方面又动用到一小部分额外的线程协助实现异步。程序员没有机会直接创建线程，这也是有的同学想当然的认为NodeJS的单线程无法很好的利用多核CPU的原因，他们甚至会说，难以想象由多人一起协作开发一个单线程的程序。 NodeJS封装了内部的异步实现后，导致程序员无法直接操作线程，也就造成所有的业务逻辑运算都会丢到JavaScript的执行线程上，这也就意味着，在高并发请求的时候，I/O的问题是很好的解决了，但是所有的业务逻辑运算积少成多地都运行在JavaScript线程上，形成了一条拥挤的JavaScript运算线程。NodeJS的弱点在这个时候会暴露出来，单线程执行运算形成的瓶颈，拖慢了I/O的效率。这大概可以算得上是密集运算情况下无法很好利用多核CPU的缺点。这条拥挤的JavaScript线程，给I/O形成了性能上限。 但是，事情又并非绝对的。回到前端浏览器中，为了解决线程拥挤的情况，Web Worker应运而生。而同样，Node也提供了child_process.fork来创建Node的子进程。在一个Node进程就能很好的解决密集I/O的情况下，fork出来的其余Node子进程可以当作常驻服务来解决运算阻塞的问题（将运算分发到多个Node子进程中上去，与Apache创建多个子进程类似）。当然child_process/Web Worker的机制永远只能解决单台机器的问题，大的Web应用是不可能一台服务器就能完成所有的请求服务的。拜NodeJS在I/O上的优势，跨OS的多Node之间通信的是不算什么问题的。解决NodeJS的运算密集问题的答案其实也是非常简单的，就是将运算分发到多个CPU上。 模块 编写稍大一点的程序时一般都会将代码模块化。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。 在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。 require require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。 exports exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。 module 通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。123module.exports = function () &#123; console.log('Hello World!');&#125;; 以上代码中，模块默认导出对象被替换为一个函数。 模块初始化 一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。 主模块 通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，main.js就是主模块。1node main.js 二进制模块 虽然一般我们使用JS编写模块，但Node.js也支持使用C/C++编写二进制模块。编译好的二进制模块除了文件扩展名是.node外，和JS模块的使用方式相同。虽然二进制模块能使用操作系统提供的所有功能，拥有无限的潜能，但对于前端同学而言编写过于困难，并且难以跨平台使用。]]></content>
      <categories>
        <category>Backend</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Backend</tag>
      </tags>
  </entry>
</search>
